#!/usr/bin/bash
##*	File: reekee
##*	Author: Will
export WD_SWASSEMBLY='reekee'

source plugin/wd/wd_aux.sh
source plugin/wd/wd_errs.sh

export BARGS_VARS_PATH="${PWD}/plugin/bargs/bargs_vars"
source plugin/bargs/bargs.sh


##*	region Aliases
alias ifDebug='[[ ! -z "$debug" ]] && [[ "$debug" != false ]] && [[ "$debug" != "0" ]] && '
alias ifVerbose='([[ ! -z "$verbose" ]] && [[ "$verbose" != false ]] && [[ "$verbose" != "0" ]] ) && '
alias ifNotQuiet='([[ -z "$quiet" ]] || [[ "$quiet" == false ]] || [[ "$quiet" == "0" ]] && '
alias ifPromptOutPass='[[ ! -z "$prompt_output_password" ]] && [[ "$prompt_output_password" != false ]] && [[ "$prompt_output_password" != "0" ]] && '
alias ifPromptInPass='[[ ! -z "$prompt_input_password" ]] && [[ "$prompt_input_password" != false ]] && [[ "$prompt_input_password" != "0" ]] && '
alias ifSDOutPass='[[ ! -z "$sd_outpass" ]] && [[ "$sd_outpass" != false ]] && [[ "$sd_outpass" != "0" ]] && '
alias ifSDInPass='[[ ! -z "$sd_inpass" ]] && [[ "$sd_inpass" != false ]] && [[ "$sd_inpass" != "0" ]] && '
alias secureDelete='shred -fun 8 ' # TODO: something better than this
shopt -s expand_aliases
##*	endregion

##*	region Constants
## User configurable
unset defaultCreateOptions
unset defaultCreateRedirects
unset defaultMergeOptions
unset defaultMergeRedirects


## Recommended default behavior established below:
## if verbose OR debug, then don't pass the -q option
## if debug then additionally, don't redirect stderr to /dev/null
eval ifDebug true || ifVerbose defaultCreateOptions=""
[ -z ${defaultCreateOptions+x} ] \
	&& defaultCreateOptions="-q"

ifDebug defaultCreateRedirects=""
[ -z ${defaultCreateRedirects+x} ] \
	&& defaultCreateRedirects=" 2&> /dev/null"

eval ifDebug true || ifVerbose defaultMergeOptions=""
[ -z ${defaultMergeOptions+x} ] \
	&& defaultMergeOptions="-q"

ifDebug defaultMergeRedirects=""
[ -z ${defaultMergeRedirects+x} ] \
	&& defaultMergeRedirects=" 2 &> /dev/null"

##*	endregion




##*	region Startup Checks
export WD_SWCOMPONENT='startup'
######################################################################
#####                                                               ##
####                       Startup Checks                          ###
###                          vim mark S                           ####
##                                                               #####
######################################################################
ifDebug err_println 'begin'

unset my_tmpFiles
unset my_outpass_file

rmTmpFilesCommand=\
'eval "[[ ! -z \""$my_tmpFiles"\" ]] && shred -fun 5 $my_tmpFiles && err_println_basic && err_println "cleaned up tempfiles $my_tmpFiles""'

trap "exit 6" TERM
trap "exit 7" INT
trap "exit 8" QUIT

#Uncomment to always display which tempfiles were cleaned
#trap "debug=true; ifDebug err_println_basic; ifDebug err_println 'done'; $rmTmpFilesCommand" EXIT
trap "ifDebug err_println_basic; ifDebug err_println 'done'; $rmTmpFilesCommand" EXIT


# Check availability of keepassxc-cli command
kpcli="$(which keepassxc-cli)"
[ -z "$kpcli" ] \
	&& crash 11 'unable to locate keepassxc-cli command'

# Find an available tmpXXXXX.xml that we can use for exporting later
# disabled because we don't need to use an xml file after all
#tries=7
#unset xml_file
#while [ -z ${xml_file+x} ] || [ -e "$xml_file" ]; do
	#[[ $tries -le 0 ]] && crash 2 "(infinite loop safeguard) Unable to find a suitable output .xml file within the allotted number of tries"
	#xml_file="tmp$RANDOM.xml"
#done


unset WD_SWCOMPONENT
##*	endregion



##*	region Input Validation
export WD_SWCOMPONENT='input-validation'
######################################################################
#####                                                               ##
####                       Input Validation                        ###
###                          vim mark I                           ####
##                                                               #####
######################################################################
# TODO: Need to add validation checks:
#	user-specified out_password_file should be EITHER:
#		only one line long (in which case we need to duplicate that line and echo it back into that file; in which case it needs to be writable)
#			to check if file is only one line long (tested this a bit):
#			[[ "$(head -n 1 "$out_password_file")" == "$(head -n 2 "$out_password_file") ]] && echo "it's a one-liner"
#		OR exactly two lines long and both lines are identical (this format is ready to feed to keepassxc-cli)
#	user-specified in_password_file should be only one line long

[ -z "$input_fn" ] || [ ! -r "$input_fn" ] || [ ! -f "$input_fn" ] \
	&& crashland 50 'No input file specified, or the specified input file does not exist, or is not readable, or is not a regular file'

outDir="$( dirname $output_fn )"
[ ! -d "$outDir" ] || [ ! -w "$outDir" ] \
	&& crashland 58 'Output directory (destination for new kdbx) does not exist or is not writable'
[[ "$outDir" == "." ]] \
	&& outDir="./" # dirname does not append a slash to the end of . - so we will (if needed)
[ -z "$output_fn" ] || [ -d "$output_fn" ] \
	&& crashland 51 'No output file specified, or the specified output file exists and is a directory'
if [ -e "$output_fn" ]; then
	[ ! -f "$output_fn" ] \
		&& crashland 51 'Output file already exists and is not a regular file'
	[ ! -w "$output_fn" ] \
		&& crashland 51 'Output file already exists and is not writable'

	warn "Output file $output_fn already exists"
	unset ans
	promptYesNo "Overwrite existing $output_fn?" 3; ans=$?
	[ "$ans" -eq 0 ] && exit 1	# Exit (code 1) if answered no
	rm $output_fn; ans=$?

	# If there STILL exists a file $output_fn at this point, then crash
	[ -e "$output_fn" ] && crash 12 "Unable to remove pre-existing file: $output_fn (rm command exited code $ans)(debug: search $0 for Ze973)"
                               # Ze973
fi


if [ ! -z "$in_keyfile" ]; then						# If in_keyfile was specified
	if [ -e "$in_keyfile" ]; then					# ... and it exists as a file
									# ... and it's unreaadable, or is not a regular file
		[ ! -r "$in_keyfile" ] || [ ! -f "$in_keyfile" ] \
			&& crashland 52	'input keyfile specified, exists, and is either unreadable or not a regular file'
	else
		crashland 52 'input keyfile specified, but does not exist'
	fi
else
	# If in_keyfileis not well-defined, then unset it (to formalize its state)
	unset in_keyfile
fi

if [ ! -z "$out_keyfile" ]; then					# If out_keyfile was specified
	if [ -e "$out_keyfile" ]; then					# ... and it exists as a file
									# ... and it's unreaadable, or is not a regular file
		[ ! -r "$out_keyfile" ] || [ ! -f "$out_keyfile" ] \
			&& crashland 53	'output keyfile specified, exists, and is either unreadable or not a regular file'
	else	
		crashland 53 'output keyfile specified, but does not exist'
	fi
else
	# If out_keyfileis not well-defined, then unset it (to formalize its state)
	unset out_keyfile
fi

if [ ! -z "$out_password_file" ]; then
	if [ ! -f "$out_password_file" ] || [ ! -r "$out_password_file" ]; then
		crashland 54 'output password file specified, but does not exist, is not a regular file, or is not readable'
	fi
else
	# If out_password_fileis not well-defined, then unset it (to formalize its state)
	unset out_password_file
fi

# if in_password_file is defined and non-empty
if [ ! -z "$in_password_file" ]; then 
	if [ ! -f "$in_password_file" ] || [ ! -r "$in_password_file" ]; then
		crashland 55 'input password file specified, but does not exist, is not a regular file, or is not readable'
	fi
else
	# If in_password_fileis not well-defined, then unset it (to formalize its state)
	unset in_password_file
fi

ifPromptInPass [ ! -z "$in_password_file" ] \
	&& crashland 57 'both prompt-in-password and in-password-file specified'
ifPromptOutPass [ ! -z "$out_password_file" ] \
	&& crashland 56 'both prompt-out-password and out-password-file specified'

unset pip
ifPromptInPass pip=''
unset pop
ifPromptOutPass pop=''

# If user asked to be prompted for input password
if [ ! -z ${pip+x} ]; then
	tries=4
	while [ -z "$pip" ]; do
		[[ $tries -le 0 ]] && crash 2 "(infinite loop safeguard) failed to enter input password within the alloted number of tries";

		read -s -p "Enter OLD (input) password: " pip
		echo

		tries=$(( $tries - 1 )) 
	done

	in_password_file="$(mktemp)"
	my_tmpFiles="$my_tmpFiles '$in_password_file'"	# Register our newly-created file for cleanup on program exit
	

	echo "$pip" > "$in_password_file"
	[ -O "$in_password_file" ] && chmod -f 600 "$in_password_file" # Make sure permissions are still the way we like em

	if [[ "$(cat $in_password_file)" == "$pip" ]]; then
		pip=''
	else
		crash 99 "Unable to copy input password to temp file in $( dirname $in_password_file )"
	fi
fi

# If user asked to be prompted for output password
if [ ! -z ${pop+x} ]; then
	ans=''
	tries=4
	while [ -z "$pop" ] || [[ "$pop" != "$ans" ]]; do
		[[ $tries -le 0 ]] && crash 2 "(infinite loop safeguard) failed to enter a password within the alloted number of s";

		read -s -p "Enter NEW (output) password: " pop
		echo

		read -s -p "Confirm NEW (output) password: " ans
		echo

		tries=$(( $tries - 1 ))
	done

	##* deprecated
	#tries=7
	#while [ -z "$out_password_file" ] || [ -e "$out_password_file" ]; do
		#[[ $tries -le 0 ]] && crash 2 "(infinite loop safeguard) failed to find a file for our output password within the alloted number of tries";
#
		#out_password_file="~/tmp$RANDOM"
#
		#tries=$(( $tries - 1 ))
	#done
	##* enddeprecated

	# RECENT CHANGE: removed a conditional wrapped around these 2 lines
	# not sure why it was there in the first place, but if something breaks,
	# you can try putting it back
	# I think it's better this way...
	# (if the conditional is needed here, then you'll also need one around line 210
	out_password_file="$(mktemp)"
	my_tmpFiles="$my_tmpFiles '$out_password_file'"	# Register our newly-created file for cleanup on program exit

	# Output the user's password to that tempfile - twice
	# We do this twice because keepassxc-cli will ask us to confirm the password
	echo "$pop" > "$out_password_file"
	echo "$pop" >> "$out_password_file"
	[ -O "$out_password_file" ] && chmod -f 600 "$out_password_file" # Make sure our permissions are still okay

	if [[ "$(head -n 1 $out_password_file)" == "$pop" ]]; then
	# Clear the password from pop for a little extra safety; we won't need it anymore
	# Note that pop remains set to empty string, rather than being unset
	# This allows us to retain knowledge of whether or not we read the output password from STDIN
	# After this,
	# 	[ -z ${pop+x} ]		will be true only if the user DID NOT supply their output password via STDIN
	# 	[ -z "$pop" ]		will always be false

		pop=''
	else
		crash 99 "Unable to copy output password to temp file $out_password_file"
	fi
fi


# Assign variables out_nop and in_nop
# After this, out_nop will be true iff there is NO output password whatsoever
# likewise in_nop for the input password
if [ -z ${pip+x} ] && [ -z "$in_password_file" ]; then
	out_nop='true'
else
	out_nop=''
fi

if [ -z ${pop+x} ] && [ -z "$out_password_file" ]; then
	in_nop='true'
else
	in_nop=''
fi
##################################################################################
##                                                                              ##
## AT THIS POINT, the following conditions are established:                     ##
##                                                                              ##
##      - IF NEITHER out-password-file NOR prompt-out-password was specified,   ##
##          (meaning that the output database will have no password)            ##
##          THEN out_nop='true'                                                 ##
##        ELSE out_nop=''                                                       ##
##      - IF NEITHER in-password-file NOR prompt-in-password was specified,     ##
##          (meaning that the user expects the input database has no password)  ##
##          THEN in_nop='true'                                                  ##
##        ELSE in_nop=''                                                        ##
##                                                                              ##
##	- If EITHER (both out-password-file and prompt-out-password)            ##
##	    OR (both in-password-file and prompt-in-password)                   ##
##	    was specified, then program has either recovered or exited          ##
##                                                                              ##
##	- If prompt-out-password was specified, then pop=''                     ##
##	    AND out_password_file="~/tmpXXXXX" (where XXXXX is a random number) ##
##          AND out_password_file contains 2 lines, both of which are the       ##
##              user-specified output password                                  ##
##	- If prompt-in-password was specified, then pip=''                      ##
##          AND in_password_file="~/tmpXXXXX" (where XXXXX is a random number)  ##
##          AND in_password_file contains 1 line, which is the user-specified   ##
##              input password                                                  ##
##                                                                              ##
##################################################################################

unset WD_SWCOMPONENT
##*	endregion




##*	region Execution
export WD_SWCOMPONENT='exec'
######################################################################
#####                                                               ##
####                          Execution                            ###
###                            mark E                             ####
##                                                               #####
######################################################################

## TODO: a lot of this could be more concisely carried out by
## input validation subrouting; it's already performing these same checks
unset createCommand
createOptions="$defaultCreateOptions"
createRedirects="$defaultCreateRedirects"
if [ ! -z "$out_keyfile" ]; then # "if out_keyfile is well-defined, then..."
	createOptions="$createOptions --set-key-file "$out_keyfile""
fi

## If there is to be a password for the output kdbx
if [ -z "$out_nop" ]; then # "if out_nop is NOT well-defined, then..."
	createOptions="$createOptions --set-password"

	[ ! -z "$out_password_file" ] \
		&& createRedirects="$createRedirects < $out_password_file"

# If there is to be NO password for the output kdbx
else
	eval '' #  Do nothing
fi

# If we have no specified file from which to read the password for our output kdbx file
if [ -z $out_password_file ] \
	|| [ ! -e $out_password_file ]; then	# Redundant Safeguard; this condition won't exist because of our input validation constraints

	# If user asked to be prompted for output pass
	if [ ! -z ${in_nop+x} ]; then
		createOptions="$createOptions --set-password"
	else
		eval ''
	fi

fi
createCommand="keepassxc-cli db-create $createOptions $output_fn $createRedirects"
#ifDebug echo "createCommand: "$createCommand""
eval $createCommand

unset mergeCommand
mergeOptions="$defaultMergeOptions"
mergeRedirects="$defaultMergeRedirects"
## If in_keyfile specified
[ ! -z "$in_keyfile" ] \
	&& mergeOptions="$mergeOptions --key-file-from "$in_keyfile"" # Stage path-to-inkeyfile as argument to keepassxc-cli merge

# If out_keyfile specified
[ ! -z "$out_keyfile" ] \
	&& mergeOptions="$mergeOptions --key-file "$out_keyfile""     # Stage path-to-outkeyfile as argument to keepassxc-cli merge

# If the input kdbx is passwordless
[ ! -z "$in_nop" ] \
	&& mergeOptions="$mergeOptions --no-password-from"            # Stage "no-password-from" option as argument to keepassxc-cli merge

# If the output kdbx is passwordless
if [ ! -z "$out_nop" ]; then
	mergeOptions="$mergeOptions --no-password"

	# If the input kdbx is passworded
	if [ -z "$in_nop" ]; then
		# Redirect input from in-password-file only if there is an input password
		#  but no output password
		mergeRedirects="$mergeRedirects < "$in_password_file""
	fi
else

##############################################################################################
#                                                                                            # 
#           # This is admittedly confusing behavior, but is done to compensate for the       #
#           # lack of ability of keepassxc-cli to accept files as inputs for passwords       #
#                                                                                            # 
#           # Since the ONLY way keepassxc-cli knows is to read it from stdin, what we       #
#           # have to do is make sure it will read the passwords it needs in the correct     #
#           # order.                                                                         #
#                                                                                            # 
#           # To accomplish this, we will use the following algoirthm:                       #
#           #        IF there exists an input password, AND no output password...            #
#           #            ( 0 ) read directly from $in_password_file - that's it!             #
#           #                                                                                #
#           #        ... Otherwise,                                                          #
#           #                                                                                #
#           #        ( 1*) Truncate our output password file to one line only                #
#           #                                                                                # 
#           #        IF there exists an input password AND an output password...             #
#           #            ( 2 ) Append input password to the end (second line)                #
#           #                 of output password                                             #
#                                                                                            # 
#                                                                                            # 
##############################################################################################
	my_outpass_file="$(mktemp)"
	my_tmpFiles="$my_tmpFiles '$my_outpass_file'"

	# Truncate out-password-file down to one line only, and put that into my_outpass_file
	echo "$( head -n 1 $out_password_file )" > "$my_outpass_file"

	# If applicable, Append the input password to my_outpass-file
	[ -z "$in_nop" ] \
		&& echo "$( head -n 1 $in_password_file )" >> "$my_outpass_file"

	# Redirect input from my_outpass_file
	mergeRedirects="$mergeRedirects < "$my_outpass_file""
fi

mergeCommand="keepassxc-cli merge $mergeOptions $output_fn $input_fn $mergeRedirects"
ifDebug echo "executing mergeCommand: "$mergeCommand""
eval $mergeCommand


unset WD_SWCOMPONENT
##*	endregion




##*	region Cleanup
export WD_SWCOMPONENT='cleanup'
######################################################################
#####                                                               ##
####                          Cleanup                              ###
###                            markC                              ####
##                                                               #####
######################################################################

[ -f $in_password_file ] \
 && [ ! -z "$sd_inpass" ] && ["$sd_inpass" -ne 0 ] && ["$sd_inpass" -ne false ] \
	&& secureDelete "$in_password_file"

[ -f $out_password_file ] \
 && [ ! -z "$sd_outpass" ] && [ "$sd_outpass" -ne 0 ] && [ "$sd_outpass" -ne false ] \
	&& secureDelete "$out_password_file"

## This section deprecated by use of trap for cleanup
## Nice going!
## If input password was entered via prompt
#if [ ! -z ${pip+x} ]; then
	## The following conditional should be practically impossible to trigger, but JUST IN CASE,
	## we'll try to add write permission to the file so that secure-delete can execute properly
	#[ ! -w "$in_password_file" ] \
		#&& chmod -f +w "$in_password_file"
#
	#secureDelete "$in_password_file"; ans=$?
#
	#[[ $ans != 0 ]] \
		#&& warn "while cleaning up "$in_password_file" - secure-delete exited with non-zero exit code $?"
	#[ -e "$in_password_file" ] \
		#&& warn "unable to automatically remove "$in_password_file" - strongly recommend you secure-delete this file manually!"
#
	#unset pip
#fi
#
## If output password was entered via prompt
#if [ ! -z ${pop+x} ]; then
	## The following conditional should be practically impossible to trigger, but JUST IN CASE,
	## we'll try to add write permission to the file if we don't already have them
	#[ ! -w "$in_password_file" ] \
		#&& chmod -f +w "$out_password_file"
	#
	#secureDelete "$out_password_file"; ans=$?
#
	#[[ $ans != 0 ]] \
		#&& warn "while cleaning up "$out_password_file" - secure-delete exited with non-zero exit code $?"
	#[ -e "$out_password_file" ] \
		#&& warn "unable to automatically remove "$out_password_file" - strongly recommend you secure-delete this file manually!"

	#unset pop
#fi

unset WD_SWCOMPONENT
##* endregion


##*	region Verify
export WD_SWCOMPONENT='verify'
######################################################################
#####                                                               ##
####                         Verification                          ###
###                            mark V                             ####
##                                                               #####
######################################################################




unset WD_SWCOMPONENT
##*	endregion




unset WD_SWASSEMBLY
##* EoF
